#!/usr/bin/env python3
""" Skeleton Implementation of Project 2 for NEU CS3700 """

import argparse
import json
import select
import socket
import ipaddress

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class RoutingInfo:
  """ This class will be the data of the routing table """

  def __init__(self, packet, srcif = None):
    if srcif == None:
      self.revoke_init(packet)
    else:
      self.update_init(srcif, packet)

  def update_init(self, srcif, packet):
    msg = packet['msg']
    netmask = ipaddress.IPv4Address(msg['netmask'])
    binary_netmask = str(bin(int(netmask)))
    self.mask_count = 0
    for i in binary_netmask:
       if i == "1":
         self.mask_count += 1
    self.cidr_network = ipaddress.ip_network(msg['network'] + "/" + str(self.mask_count))
    ## Mystery line 
    ## self.cidr_network.netmask = binary_netmask
    ## ip_network has String override that does binary and for us.
    self.network = str(self.cidr_network).split("/")[0]#  msg['network']
    self.netmask = msg['netmask']
    self.nextHop = srcif
    self.asPath = msg['ASPath']
    self.localPref = msg["localpref"]
    self.origin = msg["origin"]
    self.selfOrigin = msg["selfOrigin"]

  def revoke_init(self, packet_network_msg):
    msg = packet_network_msg
    netmask = ipaddress.IPv4Address(msg['netmask'])
    binary_netmask = str(bin(int(netmask)))
    self.mask_count = 0
    for i in binary_netmask:
       if i == "1":
         self.mask_count += 1
    self.cidr_network = ipaddress.ip_network(msg['network'] + "/" + str(self.mask_count))
    self.network = str(self.cidr_network).split("/")[0]#  msg['network']
    self.netmask = msg['netmask']

  def __eq__(self, other):
    n = self.cidr_network == other.cidr_network
    h = self.nextHop == other.nextHop
    l = self.localPref == other.localPref
    m = self.mask_count == other.mask_count
    p = self.asPath == other.asPath
    o = self.origin == other.origin
    return n and h and l and m and p and o

  def revokable(self, other):
    n = self.cidr_network == other.cidr_network
    m = self.mask_count == other.mask_count
    return n and m

  def __str__(self):
    f'Routing info is =>  network: {self.network}, netmask: {self.netmask}, nextHop: {self.nextHop}, asPath: {self.asPath}, localPref: {self.localPref}'


class Router:
    """ Your Router """

    def __init__(self, networks, asn):
        self.routes = {}
        self.updates = {}
        self.revokes = {}
        self.relations = {}
        self.sockets = {}
        self.asn = int(asn[0])
        for relationship in networks:
            network, relation = relationship.split("-")
            self.sockets[network] = socket.socket(
                socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        destination = ipaddress.IPv4Address(daddr)
        outroutes = []
        for network in self.routes.keys():
          if destination in network:
            outroutes.extend(self.routes[network])
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        shortest_length = 99999999
        for route in routes:
           aspath_length = len(route.asPath)
           if aspath_length < shortest_length:
             shortest_length = aspath_length
             outroutes = [route]
           elif aspath_length == shortest_length:
             outroutes.append(route)
        return outroutes

    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        outroutes = []
        highest_local = 0
        for route in routes:
          #print(route)
          lp = route.localPref
          if lp > highest_local:
            highest_local = route.localPref
            outroutes = [route]
          elif lp == highest_local:
            outroutes.append(route)
        return outroutes

    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO
        outroutes = []
        we_true_yet = False
        for route in routes:
          if we_true_yet and route.selfOrigin:
             outroutes.append(route)
          elif route.selfOrigin:
             we_true_yet = True
             outroutes = [route]
          else:
             outroutes.append(route)

        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        # TODO
        outroutes = []
        
        ranks = ["IGP", "EGP", "UNK"]
        current_rank = 4
        for route in routes:
          if ranks.index(route.origin) < current_rank:
            current_rank = ranks.index(route.origin)
            outroutes = [route]
          elif ranks.index(route.origin) ==  current_rank:
            outroutes.append(route)

        return outroutes

    def get_lowest_ip(self, routes):
      outroutes = []
      lowest_ip = "255.255.255.255"
      for route in routes:
        if route.nextHop < lowest_ip:
          outroutes = [route]
          lowest_ip = route.nextHop
      return outroutes
        

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        outroutes = routes
        return outroutes

    def get_route(self, srcif, daddr):
        """ Select the best route for a given address """
        # TODO
        peer = None
        routes = self.lookup_routes(daddr)
        # Rules go here
        if routes:
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            routes = self.get_lowest_ip(routes)
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
        if len(routes) == 1:
          peer = routes[0].nextHop
        else:
          print("ROUTES:\t", str(len(routes)))
        return self.sockets[peer] if peer else None

    def noRoute(self, srcif, packet):
        packet['type'] = "no route"
        #packet['src'] = self.create_ip_src(srcif) 
        packet['msg'] = {}
        #print("NO ROUTE PACKET SENDING")
        self.sockets[srcif].send(json.dumps(packet).encode())
        return False
     
    def forward(self, srcif, packet):
      """ Forward a data packet """
      counter = 0
      peer = self.get_route(srcif, packet["dst"])
      if peer == None:
        #self.noRoute(srcif, packet)
        return False
      else:
        '''
        print(packet)
        print(peer) 
        counter += 1
        print(counter)
        '''
        #print("SENDING FORWARD")
        peer.send(json.dumps(packet).encode())
        return True

    def coalesce(self):
        """ coalesce any routes that are right next to each other """
        # TODO (this is the most difficult task, save until last)
        return False

    def update(self, srcif, packet):

      # If this packet has already passed through here before, drop it.
      update_msg = packet['msg']
      if self.asn in update_msg["ASPath"]:
        return False
        
      """ handle update packets """
      self.updates[srcif] = packet # Save update info for later.
      routingInfoObject = RoutingInfo(packet, srcif=srcif) # Make the routing info object.
      routingTableKey = routingInfoObject.cidr_network # Get the key from the object.

      if routingTableKey in self.routes.keys():
        if not routingInfoObject in self.routes[routingTableKey]:
          self.routes[routingTableKey].append(routingInfoObject)
        else:
          return False
      else:
        # Add an entry into our routing table
        self.routes[routingTableKey] = [routingInfoObject]

      # Create the packet to broadcast.
      update_packet = {}
      update_packet['type'] = 'update'
      update_msg["ASPath"].append(self.asn)
      update_packet['msg'] = update_msg
      counter = 0
      for network, s in self.sockets.items():
        if srcif != network:
          self.create_ip_src(network)
          update_packet['src'] = self.create_ip_src(network)
          update_packet['dst'] = network
          #print("SENDING UPDATE")
          s.send(json.dumps(update_packet).encode())
      return True

    def create_ip_src(self, ip):
        """Change ip to src ip"""
        iplist = ip.split(".")
        iplist[3] = "1"
        return ".".join(iplist)

    def revoke(self, packet):
        """ handle revoke packets """
        peer = packet['src']
        self.revokes[peer] = packet
        network_route_pairs = self.get_networks_on_peer(peer)
        networks_to_revoke = []
        for network in packet["msg"]:
          networks_to_revoke.append(RoutingInfo(network))

        for network_route_pair in network_route_pairs:
          for network_to_revoke in networks_to_revoke:
            if network_route_pair[1].revokable(network_to_revoke):
              self.remove_route(network_route_pair)
              return True
        
        return True

    def get_networks_on_peer(self, peer):
        routes = []
        for network, routes_list in self.routes.items():
            for route_info in routes_list:
                if route_info.nextHop == peer:
                    routes.append([network, route_info])
        return routes

    def remove_route(self, network_route_pair):
        network = network_route_pair[0]
        routeInfo = network_route_pair[1]
        self.routes[network].remove(routeInfo)
        if self.routes[network] == [] or self.routes[network] == None:
           del self.routes[network]
        

    def dump(self, packet):
        """ handles dump table requests """
        table_dump = {}
        table_dump['dst'] = packet['src']
        table_dump['src'] = packet['dst']
        table_dump['type'] = TABL
        table_msg = []
        for cidr_network, routeObjects in self.routes.items():
            for routeObject in routeObjects:
                msg = {}
                msg["network"] = routeObject.network
                msg["netmask"] = routeObject.netmask
                msg["peer"] = routeObject.nextHop
                table_msg.append(msg)

        table_dump['msg'] = table_msg

        table_json = json.dumps(table_dump)
        s = self.sockets[packet['src']]
        #print("SENDING DUMP")
        s.send(table_json.encode())
        return True

    def handle_packet(self, srcif, packet):
      """ dispatches a packet by determing the packets type """
      if (packet['type'] == UPDT):
        return self.update(srcif, packet)
      elif (packet['type'] == DUMP):
        return self.dump(packet)
      elif (packet['type'] == DATA):
        return self.forward(srcif, packet)
      elif (packet['type'] == RVKE):
        #print("REVOKE PACKET")
        #print(packet)
        return self.revoke(packet)


    def send_error(self, conn, msg):
        msg['type'] = "no route"
        #packet['src'] = self.create_ip_src(srcif) 
        msg['msg'] = {}
        #print("NO ROUTE PACKET SENDING")
        conn.send(json.dumps(msg).encode())
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        """ main loop for the router """
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            srcif = sock
                    msg = json.loads(k)

                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return False


if __name__ == "__main__":
    PARSER = argparse.ArgumentParser(description='route packets')
    PARSER.add_argument('asn', metavar='asn', type=str, nargs=1, help="asn")
    PARSER.add_argument('networks', metavar='networks',
                        type=str, nargs='+', help="networks")
    ARGS = PARSER.parse_args()
    Router(ARGS.networks, ARGS.asn).run()
